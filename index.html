<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>è³‡æ–™å¤¾æª”æ¡ˆè®€å–å™¨ (é€²éšç‰ˆ)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f0f2f5;
        color: #333;
        line-height: 1.6;
    }
    .page-container {
        width: 90%;
        max-width: 800px;
        margin: 30px auto;
        padding: 20px;
    }
    .step {
        background-color: #fff;
        padding: 25px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        margin-bottom: 30px;
    }
    .step h2 {
        margin-top: 0;
        color: #0056b3;
        border-bottom: 2px solid #eef;
        padding-bottom: 10px;
        margin-bottom: 20px;
    }
    .step h3 {
        margin-top: 20px;
        margin-bottom: 10px;
        color: #17a2b8;
    }
    .input-group {
        margin-bottom: 20px;
    }
    .input-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
    }
    .input-group label[for="includeTreeCheckbox"] {
        display: inline-flex;
        align-items: center;
        font-weight: normal;
        cursor: pointer;
    }
    .input-group input[type="checkbox"] {
        margin-right: 8px;
        width: 16px;
        height: 16px;
    }
    input[type="file"], input[type="text"], input[type="number"] {
        width: calc(100% - 24px);
        padding: 10px 12px;
        border: 1px solid #ccc;
        border-radius: 6px;
        font-size: 15px;
        box-sizing: border-box;
    }
    /* Specific width for number input */
    .advanced-filter-group input[type="number"] {
        width: 120px;
        margin-right: 10px;
    }
    button {
        padding: 10px 18px;
        border: none;
        border-radius: 6px;
        font-size: 15px;
        color: white;
        background-color: #007bff;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.1s;
        margin-top: 5px;
    }
    button:hover {
        background-color: #0056b3;
    }
    button:active { transform: scale(0.98); }
    button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }
    .button-group {
        margin-top: 15px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center; /* Align items vertically */
    }
    .type-filter button { background-color: #17a2b8; }
    .type-filter button:hover { background-color: #117a8b; }
    #fileTree {
        border: 1px solid #ddd;
        padding: 15px;
        border-radius: 6px;
        max-height: 50vh;
        overflow-y: auto;
        background-color: #fdfdfd;
    }
    #fileTree ul {
        list-style-type: none;
        padding-left: 20px;
        margin: 0;
        position: relative;
    }
    #fileTree ul::before {
        content: ''; position: absolute; left: 10px; top: 0; bottom: 0;
        border-left: 1px dotted #bbb;
    }
    #fileTree li { margin-bottom: 8px; position: relative; padding-left: 25px; }
    #fileTree li::before {
        content: ''; position: absolute; top: 12px; left: -15px;
        width: 15px; border-top: 1px dotted #bbb;
    }
    #fileTree li:last-child::after {
        content: ''; position: absolute; left: -15px; top: 13px; bottom: 0;
        border-left: 2px solid #fdfdfd;
    }
    #fileTree input[type="checkbox"] { display: none; }
    #fileTree label {
        cursor: pointer; padding-left: 35px; position: relative;
        font-size: 16px; line-height: 24px; display: inline-flex;
        align-items: center; min-height: 24px;
    }
    #fileTree label .label-text { display: inline-block; vertical-align: middle; }
    #fileTree label .file-meta {
        font-size: 0.8em;
        color: #6c757d;
        margin-left: 10px;
        font-style: italic;
    }
    #fileTree label::before {
        content: ''; position: absolute; left: 0; top: 50%;
        transform: translateY(-50%); width: 22px; height: 22px;
        border: 2px solid #007bff; border-radius: 4px;
        background-color: #fff; box-sizing: border-box;
        transition: background-color 0.2s, border-color 0.2s;
    }
    #fileTree input[type="checkbox"]:checked + label::before {
        background-color: #007bff; border-color: #007bff;
    }
    #fileTree input[type="checkbox"]:checked + label::after {
        content: 'âœ”'; position: absolute; left: 5px; top: 50%;
        transform: translateY(-50%); font-size: 15px; font-weight: bold;
        color: white; line-height: 1;
    }
    #outputArea {
        width: 100%; min-height: 300px; height: 60vh;
        margin-top: 10px; padding: 12px; border: 1px solid #ccc;
        border-radius: 6px; box-sizing: border-box; font-family: 'Courier New', Courier, monospace;
        white-space: pre; background-color: #f8f9fa; font-size: 14px;
    }
    #status { margin-top: 15px; font-style: italic; color: #555; }
    #tokenInfo {
        margin-top: 15px; padding: 10px; background-color: #e9ecef;
        border-radius: 6px; font-size: 14px; font-weight: bold;
    }
    #tokenCount { color: #0056b3; }
    button.secondary { background-color: #6c757d; }
    button.secondary:hover { background-color: #545b62; }
    button.danger { background-color: #dc3545; }
    button.danger:hover { background-color: #b02a37; }
    
    /* NEW: Advanced filter container */
    .advanced-filter-container {
        padding: 15px;
        background-color: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 8px;
        margin-top: 20px;
    }
    .advanced-filter-group {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
    }
</style>
</head>
<body>
    <div class="page-container">
        <h1>è³‡æ–™å¤¾æª”æ¡ˆè®€å–å™¨ (é€²éšç‰ˆ)</h1>
        <p>æœ¬å·¥å…·å°‡å¼•å°æ‚¨å®Œæˆé¸æ“‡è³‡æ–™å¤¾ã€ç¯©é¸æª”æ¡ˆä¸¦åˆä½µå…¶å…§å®¹çš„æ­¥é©Ÿã€‚æ‰€æœ‰æ“ä½œå‡åœ¨ç›®å‰é é¢ä¾åºé€²è¡Œã€‚</p>

        <div class="step" id="step1-folder-select">
            <h2>æ­¥é©Ÿ 1ï¼šé¸æ“‡è³‡æ–™å¤¾</h2>
            <div class="input-group">
                <label for="folderInput">é»æ“Šä¸‹æ–¹æŒ‰éˆ•é¸æ“‡æ‚¨çš„è³‡æ–™å¤¾ï¼š</label>
                <input type="file" id="folderInput" webkitdirectory directory multiple>
            </div>
            <p>é¸æ“‡è³‡æ–™å¤¾å¾Œï¼Œå·¥å…·å°‡è‡ªå‹•åˆ†ææª”æ¡ˆã€ä¼°ç®— Token ä¸¦é å…ˆå–æ¶ˆå‹¾é¸éæ–‡å­—æª”æˆ–éå¤§çš„æª”æ¡ˆã€‚</p>
        </div>

        <div class="step" id="step2-file-tree-filter" style="display: none;">
            <h2>æ­¥é©Ÿ 2ï¼šæª”æ¡ˆé¸æ“‡èˆ‡ç¯©é¸</h2>
            
            <div class="input-group">
                <input type="checkbox" id="includeTreeCheckbox" checked>
                <label for="includeTreeCheckbox">åœ¨è¼¸å‡ºé–‹é ­åŠ å…¥å®Œæ•´ç›®éŒ„çµæ§‹æ–‡å­—</label>
            </div>

            <!-- === NEW: Advanced Filter Section === -->
            <div class="advanced-filter-container">
                <h3>é€²éšç¯©é¸</h3>
                <div class="advanced-filter-group">
                    <label for="sizeLimitInput">å»é™¤å¤§æ–¼ (KB):</label>
                    <input type="number" id="sizeLimitInput" value="4096" min="1">
                    <button id="deselectBySizeBtn" class="secondary">åŸ·è¡Œå»é™¤</button>
                </div>
                <div class="advanced-filter-group">
                     <button id="deselectNonTextBtn" class="secondary">å»é™¤å¸¸è¦‹éæ–‡å­—æª”</button>
                </div>
            </div>

            <div class="input-group">
                <h3>ä¾é¡å‹ç¯©é¸æª”æ¡ˆ</h3>
                <input type="text" id="fileTypeInput" placeholder="ä¾‹å¦‚ï¼š.py, .txt (é€—è™Ÿåˆ†éš”)">
                <div class="button-group type-filter">
                    <button id="selectByTypeBtn">é¸å–æ­¤é¡å‹</button>
                    <button id="deselectByTypeBtn">å–æ¶ˆæ­¤é¡å‹</button>
                </div>
            </div>
            
            <h3>æª”æ¡ˆçµæ§‹æ¨¹</h3>
            <div id="fileTree">è«‹å…ˆåœ¨æ­¥é©Ÿ 1 é¸æ“‡ä¸€å€‹è³‡æ–™å¤¾</div>

            <div id="status"></div>
            <div class="button-group">
                <button id="processButton">å‰å¾€æ­¥é©Ÿ 3ï¼šç”¢ç”Ÿåˆä½µå…§å®¹</button>
                <button id="backToStep1Button" class="secondary">è¿”å›æ­¥é©Ÿ 1 é‡æ–°é¸æ“‡è³‡æ–™å¤¾</button>
            </div>
        </div>

        <div class="step" id="step3-output" style="display: none;">
             <h2>æ­¥é©Ÿ 3ï¼šåˆä½µå…§å®¹é è¦½èˆ‡åŒ¯å‡º</h2>
            <textarea id="outputArea" readonly placeholder="é¸å–çš„æª”æ¡ˆå…§å®¹å°‡æœƒé¡¯ç¤ºåœ¨é€™è£¡..."></textarea>
            <div id="tokenInfo">é ä¼° Token æ•¸é‡ï¼š<span id="tokenCount">0</span></div>
            <div class="button-group">
                <button id="copyToClipboardButton">è¤‡è£½åˆ°å‰ªè²¼ç°¿</button>
                <button id="downloadTxtButton">ä¸‹è¼‰ TXT</button>
                <button id="splitDownloadButton" class="secondary">åˆ†å‰²ä¸‹è¼‰ (ä¾ Token)</button>
                <button id="downloadPdfButton">ä¸‹è¼‰ PDF</button>
                <button id="backToStep2Button" class="secondary">è¿”å›æ­¥é©Ÿ 2 ä¿®æ”¹é¸æ“‡</button>
                <button id="resetButton" class="danger">å…¨éƒ¨é‡ä¾† (è¿”å›æ­¥é©Ÿ 1)</button>
            </div>
        </div>
    </div>

<script>
    // --- DOM Element References ---
    const folderInput = document.getElementById('folderInput');
    const fileTreeDiv = document.getElementById('fileTree');
    const processButton = document.getElementById('processButton');
    const outputArea = document.getElementById('outputArea');
    const statusDiv = document.getElementById('status');
    const fileTypeInput = document.getElementById('fileTypeInput');
    const selectByTypeBtn = document.getElementById('selectByTypeBtn');
    const deselectByTypeBtn = document.getElementById('deselectByTypeBtn');
    const step1Div = document.getElementById('step1-folder-select');
    const step2Div = document.getElementById('step2-file-tree-filter');
    const step3Div = document.getElementById('step3-output');
    const backToStep1Button = document.getElementById('backToStep1Button');
    const backToStep2Button = document.getElementById('backToStep2Button');
    const resetButton = document.getElementById('resetButton');
    const copyToClipboardButton = document.getElementById('copyToClipboardButton');
    const downloadTxtButton = document.getElementById('downloadTxtButton');
    const downloadPdfButton = document.getElementById('downloadPdfButton');
    const includeTreeCheckbox = document.getElementById('includeTreeCheckbox');
    const tokenCountSpan = document.getElementById('tokenCount');
    const splitDownloadButton = document.getElementById('splitDownloadButton');

    // --- NEW DOM References ---
    const sizeLimitInput = document.getElementById('sizeLimitInput');
    const deselectBySizeBtn = document.getElementById('deselectBySizeBtn');
    const deselectNonTextBtn = document.getElementById('deselectNonTextBtn');

    // --- Global State & Constants ---
    let fileSystemTree = new Map();
    let allFileObjects = [];
    let lastSelectedFiles = [];
    const NON_TEXT_EXTENSIONS = new Set([
        '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp', '.svg',
        '.mp3', '.wav', '.ogg', '.m4a', '.flac',
        '.mp4', '.mov', '.avi', '.wmv', '.mkv', '.flv',
        '.zip', '.rar', '.7z', '.tar', '.gz',
        '.exe', '.dll', '.so', '.dmg', '.app',
        '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',
        '.db', '.sqlite', '.dat',
        '.pyc', '.o', '.class', '.jar', '.lock'
    ]);


    // --- Event Listeners ---
    document.addEventListener('DOMContentLoaded', () => showStep('step1-folder-select'));
    folderInput.addEventListener('change', handleFolderSelect);
    processButton.addEventListener('click', generateOutput);
    selectByTypeBtn.addEventListener('click', () => filterByType(true));
    deselectByTypeBtn.addEventListener('click', () => filterByType(false));
    backToStep1Button.addEventListener('click', resetAndGoToStep1);
    backToStep2Button.addEventListener('click', () => showStep('step2-file-tree-filter'));
    resetButton.addEventListener('click', resetAndGoToStep1);
    copyToClipboardButton.addEventListener('click', handleCopyToClipboard);
    downloadTxtButton.addEventListener('click', handleDownloadTxt);
    downloadPdfButton.addEventListener('click', handleDownloadPdf);
    splitDownloadButton.addEventListener('click', handleSplitDownload);
    
    // --- NEW Event Listeners ---
    deselectBySizeBtn.addEventListener('click', handleDeselectBySize);
    deselectNonTextBtn.addEventListener('click', handleDeselectNonText);

    fileTreeDiv.addEventListener('change', (event) => {
        if (event.target.type === 'checkbox') {
            const path = event.target.dataset.path;
            const node = findNodeByPath(path, fileSystemTree);
            if (node) {
                // User interactions should propagate to children
                updateSelectionState(node, event.target.checked, true); 
            }
        }
    });

    // --- Core Functions ---

    function showStep(stepIdToShow) {
        [step1Div, step2Div, step3Div].forEach(step => {
            step.style.display = (step.id === stepIdToShow) ? 'block' : 'none';
        });
        const activeStep = document.getElementById(stepIdToShow);
        if (activeStep) {
            setTimeout(() => activeStep.scrollIntoView({ behavior: 'smooth', block: 'start' }), 50);
        }
    }

    function resetAndGoToStep1() {
        folderInput.value = ""; 
        fileSystemTree.clear();
        allFileObjects = [];
        lastSelectedFiles = [];
        fileTreeDiv.innerHTML = 'è«‹å…ˆåœ¨æ­¥é©Ÿ 1 é¸æ“‡ä¸€å€‹è³‡æ–™å¤¾';
        outputArea.value = '';
        statusDiv.textContent = '';
        fileTypeInput.value = '';
        includeTreeCheckbox.checked = true;
        tokenCountSpan.textContent = '0';
        showStep('step1-folder-select');
    }

    async function handleFolderSelect(event) {
        const files = event.target.files;
        if (!files.length) return;

        statusDiv.textContent = 'æ­£åœ¨å»ºç«‹æª”æ¡ˆæ¨¹...';
        fileSystemTree.clear();
        allFileObjects = Array.from(files);

        // Build the basic tree structure
        for (const file of allFileObjects) {
            const pathParts = file.webkitRelativePath.split('/');
            let currentLevel = fileSystemTree;
            let currentPath = [];
            for (let i = 0; i < pathParts.length; i++) {
                const part = pathParts[i];
                currentPath.push(part);
                const nodePath = currentPath.join('/');
                if (i === pathParts.length - 1) { 
                    if (!currentLevel.has(part)) {
                         currentLevel.set(part, {
                            name: part, type: 'file', path: nodePath,
                            fileObject: file, selected: true, children: null
                        });
                    }
                } else { 
                    if (!currentLevel.has(part)) {
                        currentLevel.set(part, {
                            name: part, type: 'folder', path: nodePath,
                            selected: true, children: new Map()
                        });
                    }
                    if (currentLevel.get(part).type === 'file') { 
                        currentLevel.get(part).type = 'folder';
                        currentLevel.get(part).children = currentLevel.get(part).children || new Map();
                        currentLevel.get(part).selected = true;
                    }
                    currentLevel = currentLevel.get(part).children;
                }
            }
        }
        
        renderFileTree();
        statusDiv.textContent = `å·²è¼‰å…¥ ${allFileObjects.length} å€‹é …ç›®ã€‚æ­£åœ¨åˆ†ææª”æ¡ˆå…§å®¹...`;
        showStep('step2-file-tree-filter');

        // Asynchronously process metadata and apply default filters
        await processFileMetadataAndApplyDefaults();
    }

    /**
     * @async
     * NEW: Iterates through all files, reads them, estimates tokens,
     * and applies the initial filtering logic.
     */
    async function processFileMetadataAndApplyDefaults() {
        const fileNodes = getAllFileNodes(fileSystemTree);
        let processedCount = 0;
        let deselectedCount = 0;

        for (const node of fileNodes) {
            let isText = isLikelyTextFile(node.name);
            let tokens = 0;
            let fileContent = '';

            try {
                if (isText) {
                    fileContent = await node.fileObject.text();
                    tokens = estimateTokens(fileContent);
                }
                
                // Update the UI with metadata
                updateFileNodeLabel(node, tokens, isText);

                // Apply initial deselection logic
                if (!isText || tokens > 50000) {
                    updateSelectionState(node, false, false); // No propagation for this auto-action
                    deselectedCount++;
                }
            } catch (e) {
                console.error(`Error processing file ${node.path}:`, e);
                updateFileNodeLabel(node, 0, false, "[è®€å–éŒ¯èª¤]");
                updateSelectionState(node, false, false);
                deselectedCount++;
            }

            processedCount++;
            statusDiv.textContent = `åˆ†æé€²åº¦: ${processedCount} / ${fileNodes.length} å€‹æª”æ¡ˆã€‚å·²è‡ªå‹•å–æ¶ˆå‹¾é¸ ${deselectedCount} å€‹ã€‚`;
        }
        statusDiv.textContent = `åˆ†æå®Œæˆï¼å…± ${fileNodes.length} å€‹æª”æ¡ˆï¼Œå·²è‡ªå‹•å–æ¶ˆå‹¾é¸ ${deselectedCount} å€‹éæ–‡å­—æª”æˆ–éå¤§æª”æ¡ˆã€‚`;
    }

    function renderFileTree() {
        fileTreeDiv.innerHTML = '';
        const rootUl = document.createElement('ul');
        appendTreeNodes(fileSystemTree, rootUl);
        fileTreeDiv.appendChild(rootUl);
    }
    
    function appendTreeNodes(nodeMap, parentElement) {
        const sortedEntries = [...nodeMap.entries()].sort(([keyA, valA], [keyB, valB]) => {
            if (valA.type === 'folder' && valB.type === 'file') return -1;
            if (valA.type === 'file' && valB.type === 'folder') return 1;
            return keyA.localeCompare(keyB);
        });

        for (const [name, node] of sortedEntries) {
            const li = document.createElement('li');
            const randomSuffix = Math.random().toString(36).substring(2, 7);
            const checkboxId = `cb-${node.path.replace(/[^a-zA-Z0-9_-]/g, '_')}-${randomSuffix}`;
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = checkboxId;
            checkbox.checked = node.selected;
            checkbox.dataset.path = node.path;
            
            const label = document.createElement('label');
            label.htmlFor = checkboxId;

            const labelTextSpan = document.createElement('span');
            labelTextSpan.classList.add('label-text');
            const icon = node.type === 'folder' ? 'ğŸ“ ' : 'ğŸ“„ ';
            labelTextSpan.textContent = icon + node.name;
            
            // NEW: Span for metadata
            const metaSpan = document.createElement('span');
            metaSpan.classList.add('file-meta');
            if (node.type === 'file') {
                 metaSpan.textContent = '(åˆ†æä¸­...)';
            }

            label.appendChild(labelTextSpan);
            label.appendChild(metaSpan);
            li.appendChild(checkbox);
            li.appendChild(label);
            
            // Store references to DOM elements on the node object
            node.checkboxElement = checkbox; 
            node.metaElement = metaSpan;

            if (node.type === 'folder' && node.children && node.children.size > 0) {
                const childrenUl = document.createElement('ul');
                appendTreeNodes(node.children, childrenUl);
                li.appendChild(childrenUl);
            }
            parentElement.appendChild(li);
        }
    }
    
    /**
     * NEW: Updates the file node's label in the DOM with token and size info.
     */
    function updateFileNodeLabel(node, tokens, isText, errorMsg = '') {
        if (!node.metaElement) return;

        if (errorMsg) {
            node.metaElement.textContent = errorMsg;
            node.metaElement.style.color = '#dc3545';
            return;
        }

        const fileSizeKB = (node.fileObject.size / 1024).toFixed(2);
        if (isText) {
            node.metaElement.textContent = `(${tokens.toLocaleString()} Tokens, ${fileSizeKB} KB)`;
            node.metaElement.style.color = tokens > 50000 ? '#dc3545' : '#6c757d';
        } else {
            node.metaElement.textContent = `(éæ–‡å­—æª”, ${fileSizeKB} KB)`;
            node.metaElement.style.color = '#dc3545';
        }
    }
    
    function findNodeByPath(path, currentMapLevel) {
        const parts = path.split('/');
        let node = null;
        let currentLevel = currentMapLevel;
        for (const part of parts) {
            if (!currentLevel || !currentLevel.has(part)) return null;
            node = currentLevel.get(part);
            currentLevel = (node.type === 'folder') ? node.children : null;
        }
        return node;
    }
    
    function updateSelectionState(node, isSelected, isUserInteraction) {
        node.selected = isSelected;
        if (node.checkboxElement) node.checkboxElement.checked = isSelected;

        // If a user clicks a folder, propagate the change to all children
        if (node.type === 'folder' && node.children && isUserInteraction) {
            for (const childNode of node.children.values()) {
                updateSelectionState(childNode, isSelected, isUserInteraction); 
            }
        }
    }

    // --- Filter and Action Functions ---

    /**
     * NEW: Handles the "Deselect by Size" button click.
     */
    function handleDeselectBySize() {
        const sizeLimitKB = parseFloat(sizeLimitInput.value);
        if (isNaN(sizeLimitKB) || sizeLimitKB <= 0) {
            alert("è«‹è¼¸å…¥ä¸€å€‹æœ‰æ•ˆçš„æª”æ¡ˆå¤§å° (KB)ã€‚");
            return;
        }
        const sizeLimitBytes = sizeLimitKB * 1024;
        let count = 0;
        getAllFileNodes(fileSystemTree).forEach(node => {
            if (node.fileObject.size > sizeLimitBytes) {
                if (node.selected) {
                    updateSelectionState(node, false, false);
                    count++;
                }
            }
        });
        statusDiv.textContent = `æ“ä½œå®Œæˆï¼šå·²å–æ¶ˆå‹¾é¸ ${count} å€‹å¤§æ–¼ ${sizeLimitKB} KB çš„æª”æ¡ˆã€‚`;
    }

    /**
     * NEW: Handles the "Deselect Non-Text" button click.
     */
    function handleDeselectNonText() {
        let count = 0;
        getAllFileNodes(fileSystemTree).forEach(node => {
            if (!isLikelyTextFile(node.name)) {
                if (node.selected) {
                    updateSelectionState(node, false, false);
                    count++;
                }
            }
        });
        statusDiv.textContent = `æ“ä½œå®Œæˆï¼šå·²å–æ¶ˆå‹¾é¸ ${count} å€‹å¸¸è¦‹çš„éæ–‡å­—æª”æ¡ˆã€‚`;
    }

    function filterByType(select) {
        const typesString = fileTypeInput.value.trim();
        if (!typesString) {
            alert('è«‹è¼¸å…¥è¦ç¯©é¸çš„æª”æ¡ˆé¡å‹ï¼Œä¾‹å¦‚ .txt, .js');
            return;
        }
        const types = typesString.split(',').map(t => t.trim().toLowerCase()).filter(t => t.startsWith('.'));
        if (!types.length) {
            alert('ç„¡æ•ˆçš„æª”æ¡ˆé¡å‹æ ¼å¼ã€‚è«‹ç¢ºä¿ä»¥ . é–‹é ­ï¼Œä¾‹å¦‚ .py');
            return;
        }
        let changedCount = 0;
        getAllFileNodes(fileSystemTree).forEach(node => {
            const fileExt = ('.' + node.name.split('.').pop()).toLowerCase();
            if (types.includes(fileExt)) {
                if (node.selected !== select) {
                    updateSelectionState(node, select, false);
                    changedCount++;
                }
            }
        });
        statusDiv.textContent = `å·²æŒ‰é¡å‹ ${types.join(', ')} ${select ? 'é¸å–' : 'å–æ¶ˆé¸å–'} äº† ${changedCount} å€‹æª”æ¡ˆã€‚`;
    }

    async function generateOutput() {
        outputArea.value = '';
        statusDiv.textContent = 'æ­£åœ¨è®€å–æª”æ¡ˆå…§å®¹...';
        showStep('step3-output'); 

        let outputContent = '';
        lastSelectedFiles = []; // Reset and collect again

        collectSelectedFiles(fileSystemTree);
        
        if (includeTreeCheckbox.checked) {
            outputContent += '--- ç›®éŒ„çµæ§‹ ---\n';
            outputContent += generateDirectoryTreeString(fileSystemTree, '', true);
            outputContent += '\n--- æª”æ¡ˆå…§å®¹ ---\n\n';
        }

        if (lastSelectedFiles.length === 0) {
            outputArea.value = outputContent + "æ²’æœ‰é¸å–ä»»ä½•æª”æ¡ˆã€‚";
            statusDiv.textContent = "å®Œæˆã€‚æ²’æœ‰æª”æ¡ˆå¯è™•ç†ã€‚"; 
            tokenCountSpan.textContent = estimateTokens(outputArea.value).toLocaleString();
            return;
        }

        let filesReadSoFar = 0;
        outputArea.placeholder = `æ­£åœ¨è™•ç†... å·²è®€å– 0 / ${lastSelectedFiles.length} å€‹æª”æ¡ˆã€‚`;

        for (const node of lastSelectedFiles) {
            try {
                const fileContent = await node.fileObject.text();
                outputContent += `è·¯å¾‘/${node.path}å…§å®¹å¦‚ä¸‹ï¼š\n`;
                outputContent += `${fileContent}\n\n`;
                filesReadSoFar++;
                if (filesReadSoFar % 5 === 0 || filesReadSoFar === lastSelectedFiles.length) { 
                    outputArea.placeholder = `æ­£åœ¨è™•ç†... å·²è®€å– ${filesReadSoFar} / ${lastSelectedFiles.length} å€‹æª”æ¡ˆã€‚`;
                }
            } catch (error) {
                outputContent += `è·¯å¾‘/${node.path}å…§å®¹å¦‚ä¸‹ï¼š\n[éŒ¯èª¤ï¼šç„¡æ³•è®€å–æª”æ¡ˆå…§å®¹ - ${error.message}]\n\n`;
                console.error(`è®€å–æª”æ¡ˆ ${node.path} å¤±æ•—:`, error);
            }
        }

        outputArea.value = outputContent;
        outputArea.placeholder = "é¸å–çš„æª”æ¡ˆå…§å®¹å°‡æœƒé¡¯ç¤ºåœ¨é€™è£¡...";
        statusDiv.textContent = `å®Œæˆã€‚å…±è™•ç† ${filesReadSoFar} å€‹æª”æ¡ˆã€‚çµæœé¡¯ç¤ºåœ¨æ­¥é©Ÿ 3ã€‚`;
        tokenCountSpan.textContent = estimateTokens(outputContent).toLocaleString();
    }
    
    // --- Helper and Utility Functions ---

    /**
     * NEW: Recursively collects all file nodes from the tree into a flat array.
     */
    function getAllFileNodes(nodeMap) {
        let nodes = [];
        for (const node of nodeMap.values()) {
            if (node.type === 'file') {
                nodes.push(node);
            } else if (node.type === 'folder' && node.children) {
                nodes = nodes.concat(getAllFileNodes(node.children));
            }
        }
        return nodes;
    }

    /**
     * NEW: Checks if a filename likely corresponds to a text file.
     */
    function isLikelyTextFile(filename) {
        const extension = ('.' + filename.split('.').pop()).toLowerCase();
        // A file without an extension is considered a text file by default
        if (extension === '.' + filename.toLowerCase()) return true; 
        return !NON_TEXT_EXTENSIONS.has(extension);
    }
    
    function collectSelectedFiles(nodeMap) {
        const sortedEntries = [...nodeMap.entries()].sort(([keyA, valA], [keyB, valB]) => valA.path.localeCompare(valB.path));
        for (const [name, node] of sortedEntries) {
            if (node.type === 'file' && node.selected && node.fileObject) {
                lastSelectedFiles.push(node);
            } else if (node.type === 'folder' && node.children) {
                collectSelectedFiles(node.children);
            }
        }
    }
    
    function generateDirectoryTreeString(nodeMap, prefix = '', isRoot = false) {
        let treeString = isRoot ? (allFileObjects[0]?.webkitRelativePath.split('/')[0] || 'root') + '\n' : '';
        const sortedEntries = [...nodeMap.entries()].sort(([keyA, valA], [keyB, valB]) => {
            if (valA.type === 'folder' && valB.type === 'file') return -1;
            if (valA.type === 'file' && valB.type === 'folder') return 1;
            return keyA.localeCompare(keyB);
        });
        sortedEntries.forEach((entry, index) => {
            const [name, node] = entry;
            const isLast = index === sortedEntries.length - 1;
            const connector = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
            const icon = node.type === 'folder' ? 'ğŸ“' : 'ğŸ“„';
            treeString += `${prefix}${connector}${icon} ${name}\n`;
            if (node.type === 'folder' && node.children) {
                const newPrefix = prefix + (isLast ? '    ' : 'â”‚   ');
                treeString += generateDirectoryTreeString(node.children, newPrefix);
            }
        });
        return treeString;
    }

    function estimateTokens(text) {
        if (!text) return 0;
        const cjkRegex = /[\u4e00-\u9fa5\u3040-\u30ff\uac00-\ud7af]/g;
        const cjkMatches = text.match(cjkRegex);
        const cjkChars = cjkMatches ? cjkMatches.length : 0;
        const otherChars = text.length - cjkChars;
        const tokens = Math.ceil((cjkChars * 1.5) + (otherChars * 0.3));
        return tokens;
    }
    
    // --- Existing Export Functions (Unchanged) ---
    
    async function handleSplitDownload() {
        const tokenLimitStr = prompt("è«‹è¼¸å…¥æ¯å€‹æª”æ¡ˆçš„ Token ä¸Šé™ï¼ˆä¾‹å¦‚ï¼š8000ï¼‰ã€‚\nåˆ†å‰²å°‡ä»¥æª”æ¡ˆç‚ºå–®ä½ï¼Œé¿å…æˆªæ–·å…§å®¹ã€‚", "8000");
        if (!tokenLimitStr) return;
        const tokenLimit = parseInt(tokenLimitStr, 10);
        if (isNaN(tokenLimit) || tokenLimit <= 0) {
            alert("è«‹è¼¸å…¥ä¸€å€‹æœ‰æ•ˆçš„æ­£æ•´æ•¸ã€‚");
            return;
        }
        if (lastSelectedFiles.length === 0) {
            alert("æ²’æœ‰é¸å–çš„æª”æ¡ˆå¯ä»¥åˆ†å‰²ä¸‹è¼‰ã€‚");
            return;
        }
        statusDiv.textContent = `æ­£åœ¨æº–å‚™åˆ†å‰²æª”æ¡ˆï¼Œä¸Šé™ç‚º ${tokenLimit.toLocaleString()} tokens...`;
        let chunks = [];
        let currentChunkContent = "";
        let currentChunkTokens = 0;
        let initialContent = '';
        if (includeTreeCheckbox.checked) {
            initialContent += '--- ç›®éŒ„çµæ§‹ ---\n';
            initialContent += generateDirectoryTreeString(fileSystemTree, '', true);
            initialContent += '\n--- æª”æ¡ˆå…§å®¹ ---\n\n';
        }
        currentChunkContent = initialContent;
        currentChunkTokens = estimateTokens(initialContent);
        for (const node of lastSelectedFiles) {
            try {
                const fileContent = await node.fileObject.text();
                const fileBlock = `è·¯å¾‘/${node.path}å…§å®¹å¦‚ä¸‹ï¼š\n${fileContent}\n\n`;
                const blockTokens = estimateTokens(fileBlock);
                if (currentChunkContent !== initialContent && currentChunkTokens + blockTokens > tokenLimit) {
                    chunks.push(currentChunkContent);
                    currentChunkContent = initialContent + fileBlock;
                    currentChunkTokens = estimateTokens(currentChunkContent);
                } else {
                    currentChunkContent += fileBlock;
                    currentChunkTokens += blockTokens;
                }
            } catch (error) {
                console.error(`åˆ†å‰²æ™‚è®€å–æª”æ¡ˆ ${node.path} å¤±æ•—:`, error);
                const errorBlock = `è·¯å¾‘/${node.path}å…§å®¹å¦‚ä¸‹ï¼š\n[éŒ¯èª¤ï¼šç„¡æ³•è®€å–æª”æ¡ˆå…§å®¹ - ${error.message}]\n\n`;
                currentChunkContent += errorBlock;
                currentChunkTokens += estimateTokens(errorBlock);
            }
        }
        if (currentChunkContent !== initialContent && currentChunkContent.trim() !== "") {
            chunks.push(currentChunkContent);
        }
        if (chunks.length === 0) {
            alert("æ²’æœ‰å…§å®¹å¯ä»¥ä¸‹è¼‰ã€‚");
            statusDiv.textContent = "æ“ä½œå®Œæˆã€‚";
            return;
        }
        statusDiv.textContent = `æ­£åœ¨ä¸‹è¼‰ ${chunks.length} å€‹åˆ†å‰²æª”æ¡ˆ...`;
        chunks.forEach((chunk, index) => {
            const blob = new Blob([chunk], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `merged_content_part_${index + 1}_of_${chunks.length}.txt`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        });
        statusDiv.textContent = `å·²æˆåŠŸä¸‹è¼‰ ${chunks.length} å€‹åˆ†å‰²æª”æ¡ˆã€‚`;
    }

    async function handleCopyToClipboard() {
        if (!outputArea.value) { alert('æ²’æœ‰å…§å®¹å¯è¤‡è£½ã€‚'); return; }
        try {
            await navigator.clipboard.writeText(outputArea.value);
            copyToClipboardButton.textContent = 'å·²è¤‡è£½!';
            copyToClipboardButton.disabled = true;
            setTimeout(() => {
                copyToClipboardButton.textContent = 'è¤‡è£½åˆ°å‰ªè²¼ç°¿';
                copyToClipboardButton.disabled = false;
            }, 2000);
        } catch (err) {
            console.error('ç„¡æ³•è¤‡è£½åˆ°å‰ªè²¼ç°¿:', err);
            alert('è¤‡è£½å¤±æ•—ï¼Œæ‚¨çš„ç€è¦½å™¨å¯èƒ½ä¸æ”¯æ´æ­¤åŠŸèƒ½ã€‚');
        }
    }

    function handleDownloadTxt() {
        if (!outputArea.value) { alert('æ²’æœ‰å…§å®¹å¯ä¸‹è¼‰ã€‚'); return; }
        const blob = new Blob([outputArea.value], { type: 'text/plain;charset=utf-8' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'merged_content.txt';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
    }

    function handleDownloadPdf() {
        if (!outputArea.value) { alert('æ²’æœ‰å…§å®¹å¯ä¸‹è¼‰ã€‚'); return; }
        if (typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined') {
            alert('PDF ç”Ÿæˆå‡½å¼åº« (jsPDF) æœªè¼‰å…¥ã€‚');
            return;
        }
        const { jsPDF: JsPDF } = window.jspdf;
        const doc = new JsPDF();
        doc.setFont('Courier'); 
        doc.setFontSize(10);
        const margin = 10;
        const pageWidth = doc.internal.pageSize.getWidth() - 2 * margin;
        const textLines = doc.splitTextToSize(outputArea.value, pageWidth);
        let cursorY = margin;
        const lineHeight = doc.getLineHeight() / doc.internal.scaleFactor;
        textLines.forEach(line => {
            if (cursorY + lineHeight > doc.internal.pageSize.getHeight() - margin) {
                doc.addPage();
                cursorY = margin;
            }
            doc.text(line, margin, cursorY);
            cursorY += lineHeight;
        });
        try {
            doc.save('merged_content.pdf');
        } catch (e) {
            console.error("ç”Ÿæˆ PDF æ™‚ç™¼ç”ŸéŒ¯èª¤:", e);
            alert("ç”Ÿæˆ PDF æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚éƒ¨åˆ†ç‰¹æ®Šå­—å…ƒå¯èƒ½ç„¡æ³•æ­£ç¢ºé¡¯ç¤ºã€‚");
        }
    }
</script>
</body>
</html>
