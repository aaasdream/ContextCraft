<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>è³‡æ–™å¤¾æª”æ¡ˆè®€å–å™¨ (æ­¥é©Ÿå¼)</title>
<style>
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 0; /* Body padding handled by container */
        background-color: #f0f2f5;
        color: #333;
        line-height: 1.6;
    }
    .page-container {
        width: 90%;
        max-width: 800px;
        margin: 30px auto;
        padding: 20px;
    }
    .step {
        background-color: #fff;
        padding: 25px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        margin-bottom: 30px;
    }
    .step h2 {
        margin-top: 0;
        color: #0056b3;
        border-bottom: 2px solid #eef;
        padding-bottom: 10px;
        margin-bottom: 20px;
    }
    .step h3 {
        margin-top: 20px;
        margin-bottom: 10px;
        color: #17a2b8;
    }

    /* --- æª”æ¡ˆé¸æ“‡èˆ‡æ§åˆ¶ --- */
    .input-group {
        margin-bottom: 20px;
    }
    .input-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
    }
    input[type="file"], input[type="text"] {
        width: calc(100% - 24px); /* Full width minus padding */
        padding: 10px 12px;
        border: 1px solid #ccc;
        border-radius: 6px;
        font-size: 15px;
        box-sizing: border-box;
    }
    button {
        padding: 10px 18px;
        border: none;
        border-radius: 6px;
        font-size: 15px;
        color: white;
        background-color: #007bff;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.1s;
        margin-top: 5px;
    }
    button:hover {
        background-color: #0056b3;
    }
    button:active {
        transform: scale(0.98);
    }
    .button-group {
        margin-top: 15px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
    }
    .type-filter button {
        background-color: #17a2b8;
    }
    .type-filter button:hover {
        background-color: #117a8b;
    }

    /* --- æª”æ¡ˆæ¨¹ --- */
    #fileTree {
        border: 1px solid #ddd;
        padding: 15px;
        border-radius: 6px;
        max-height: 50vh; /* Max height relative to viewport */
        overflow-y: auto;
        background-color: #fdfdfd;
    }
    #fileTree ul {
        list-style-type: none;
        padding-left: 20px; /* ä¸»è¦ç¸®æ’ï¼Œç‚ºéšå±¤ç·šç•™ç©ºé–“ */
        margin: 0;
        position: relative; /* ä½œç‚ºéšå±¤ç·šçš„å®šä½åƒè€ƒ */
    }

    /* å‚ç›´éšå±¤ç·š */
    #fileTree ul::before {
        content: '';
        position: absolute;
        left: 10px; /* å‚ç›´ç·šçš„ä½ç½® (ul padding-left çš„ä¸€åŠ) */
        top: 0;
        bottom: 0; /* é è¨­å»¶ä¼¸åˆ°åº•éƒ¨ */
        width: 0;
        border-left: 1px dotted #bbb;
    }

    #fileTree li {
        margin-bottom: 8px;
        position: relative; /* ä½œç‚º li çš„éšå±¤ç·šçš„å®šä½åƒè€ƒ */
        padding-left: 25px; /* ç‚º li çš„æ°´å¹³éšå±¤ç·šå’Œ checkbox ç•™å‡ºç©ºé–“ */
                               /* (10px åˆ°å‚ç›´ç·š + 15px æ°´å¹³ç·šé•·åº¦) */
    }

    /* æ°´å¹³éšå±¤ç·š (T å­—æˆ– L å­—çš„æ°´å¹³éƒ¨åˆ†) */
    #fileTree li::before {
        content: '';
        position: absolute;
        top: 12px; /* å¤§ç´„åœ¨ checkbox çš„å‚ç›´ä¸­é–“ */
        left: -15px; /* å¾ li æ–‡å­—å€å¡Šé–‹å§‹å¾€å·¦ç•« (25px padding - 10px ulå‚ç›´ç·šä½ç½®) */
        width: 15px; /* æ°´å¹³ç·šçš„é•·åº¦ï¼Œé€£æ¥åˆ° ul çš„å‚ç›´ç·š */
        height: 0;
        border-top: 1px dotted #bbb;
    }

    /* è™•ç†æœ€å¾Œä¸€å€‹ li ä¸‹æ–¹å¤šé¤˜çš„å‚ç›´ç·š */
    /* ç‚ºæœ€å¾Œä¸€å€‹ li ä¹‹å¾Œçš„å‚ç›´ç·šéƒ¨åˆ†ï¼Œç”¨èƒŒæ™¯è‰²è¦†è“‹æ‰ */
    #fileTree li:last-child::after {
        content: '';
        position: absolute;
        left: -15px; /* èˆ‡ li::before çš„ left å°é½Šï¼Œå³ ul å‚ç›´ç·šçš„ä½ç½® */
        top: 13px;   /* å¾æ°´å¹³ç·šä¸‹æ–¹é–‹å§‹ */
        bottom: 0;
        width: 0; /* åªæ˜¯ç‚ºäº†å®šä½ */
        /* ä½¿ç”¨ #fileTree çš„èƒŒæ™¯è‰²è¦†è“‹ */
        border-left: 2px solid #fdfdfd; /* ç¢ºä¿èƒ½è“‹ä½ dotted line */
    }


    /* --- è‡ªè¨‚ Checkbox æ¨£å¼ (ç¶­æŒä¸è®Šï¼Œä½†æ³¨æ„å…¶å®šä½æ˜¯ç›¸å°æ–¼ label) --- */
    #fileTree input[type="checkbox"] {
        display: none; /* éš±è—åŸå§‹ checkbox */
    }
    #fileTree label {
        cursor: pointer;
        padding-left: 35px; /* ç‚ºè‡ªè¨‚ checkbox ç•™å‡ºç©ºé–“ (ç›¸å°æ–¼ label çš„èµ·å§‹ä½ç½®) */
        position: relative;
        font-size: 16px;
        line-height: 24px; /* ç¢ºä¿å‚ç›´å°é½Š */
        display: inline-flex; /* è®“ label åŒ…è£¹å…§å®¹ */
        align-items: center;
        min-height: 24px; /* ç¢ºä¿æœ€å°é«˜åº¦ */
    }
    #fileTree label .label-text {
        display: inline-block;
        vertical-align: middle;
    }

    /* è‡ªè¨‚ checkbox çš„æ¡† */
    #fileTree label::before {
        content: '';
        position: absolute;
        left: 0; /* ç›¸å°æ–¼ label çš„ padding-left å€åŸŸçš„å·¦é‚Š */
        top: 50%;
        transform: translateY(-50%);
        width: 22px; /* å¢å¤§å°ºå¯¸ */
        height: 22px; /* å¢å¤§å°ºå¯¸ */
        border: 2px solid #007bff;
        border-radius: 4px;
        background-color: #fff;
        box-sizing: border-box;
        transition: background-color 0.2s, border-color 0.2s;
    }

    /* é¸ä¸­æ™‚çš„èƒŒæ™¯å’Œé‚Šæ¡† */
    #fileTree input[type="checkbox"]:checked + label::before {
        background-color: #007bff;
        border-color: #007bff;
    }

    /* é¸ä¸­æ™‚çš„å‹¾ */
    #fileTree input[type="checkbox"]:checked + label::after {
        content: 'âœ”';
        position: absolute;
        left: 5px; /* èª¿æ•´å‹¾åœ¨æ¡†å…§çš„ä½ç½® */
        top: 50%;
        transform: translateY(-50%);
        font-size: 15px;
        font-weight: bold;
        color: white;
        line-height: 1;
    }
    
    /* --- è¼¸å‡ºå€åŸŸ --- */
    #outputArea {
        width: 100%;
        min-height: 300px;
        height: 60vh; /* Relative to viewport height */
        margin-top: 10px;
        padding: 12px;
        border: 1px solid #ccc;
        border-radius: 6px;
        box-sizing: border-box;
        font-family: 'Courier New', Courier, monospace;
        white-space: pre;
        background-color: #f8f9fa;
        font-size: 14px;
    }
    #status {
        margin-top: 15px;
        font-style: italic;
        color: #555;
    }

    /* æ¬¡è¦æŒ‰éˆ•æ¨£å¼ */
    button.secondary {
        background-color: #6c757d;
    }
    button.secondary:hover {
        background-color: #545b62;
    }
    button.danger {
        background-color: #dc3545;
    }
    button.danger:hover {
        background-color: #b02a37;
    }

</style>
</head>
<body>

    <div class="page-container">
        <h1>è³‡æ–™å¤¾æª”æ¡ˆè®€å–å™¨ (æ­¥é©Ÿå¼)</h1>
        <p>æœ¬å·¥å…·å°‡å¼•å°æ‚¨å®Œæˆé¸æ“‡è³‡æ–™å¤¾ã€ç¯©é¸æª”æ¡ˆä¸¦åˆä½µå…¶å…§å®¹çš„æ­¥é©Ÿã€‚æ‰€æœ‰æ“ä½œå‡åœ¨ç›®å‰é é¢ä¾åºé€²è¡Œã€‚</p>

        <div class="step" id="step1-folder-select">
            <h2>æ­¥é©Ÿ 1ï¼šé¸æ“‡è³‡æ–™å¤¾</h2>
            <div class="input-group">
                <label for="folderInput">é»æ“Šä¸‹æ–¹æŒ‰éˆ•é¸æ“‡æ‚¨çš„è³‡æ–™å¤¾ï¼š</label>
                <input type="file" id="folderInput" webkitdirectory directory multiple>
            </div>
            <p>é¸æ“‡è³‡æ–™å¤¾å¾Œï¼Œå…¶å…§å®¹å°‡é¡¯ç¤ºåœ¨ä¸‹ä¸€æ­¥ä¾›æ‚¨é¸æ“‡ã€‚</p>
        </div>

        <div class="step" id="step2-file-tree-filter" style="display: none;">
            <h2>æ­¥é©Ÿ 2ï¼šæª”æ¡ˆé¸æ“‡èˆ‡ç¯©é¸</h2>
            <div class="input-group">
                <h3>ä¾é¡å‹ç¯©é¸æª”æ¡ˆ</h3>
                <input type="text" id="fileTypeInput" placeholder="ä¾‹å¦‚ï¼š.py, .txt (é€—è™Ÿåˆ†éš”)">
                <div class="button-group type-filter">
                    <button id="selectByTypeBtn">é¸å–æ­¤é¡å‹</button>
                    <button id="deselectByTypeBtn">å–æ¶ˆæ­¤é¡å‹</button>
                </div>
            </div>
            
            <h3>æª”æ¡ˆçµæ§‹æ¨¹</h3>
            <div id="fileTree">è«‹å…ˆåœ¨æ­¥é©Ÿ 1 é¸æ“‡ä¸€å€‹è³‡æ–™å¤¾</div>

            <div id="status"></div>
            <div class="button-group">
                <button id="processButton">å‰å¾€æ­¥é©Ÿ 3ï¼šç”¢ç”Ÿåˆä½µå…§å®¹</button>
                <button id="backToStep1Button" class="secondary">è¿”å›æ­¥é©Ÿ 1 é‡æ–°é¸æ“‡è³‡æ–™å¤¾</button>
            </div>
        </div>

        <div class="step" id="step3-output" style="display: none;">
            <h2>æ­¥é©Ÿ 3ï¼šåˆä½µå…§å®¹é è¦½</h2>
            <textarea id="outputArea" readonly placeholder="é¸å–çš„æª”æ¡ˆå…§å®¹å°‡æœƒé¡¯ç¤ºåœ¨é€™è£¡..."></textarea>
            <div class="button-group">
                <button id="backToStep2Button" class="secondary">è¿”å›æ­¥é©Ÿ 2 ä¿®æ”¹é¸æ“‡</button>
                <button id="resetButton" class="danger">å…¨éƒ¨é‡ä¾† (è¿”å›æ­¥é©Ÿ 1)</button>
            </div>
        </div>
    </div>

<script>
    const folderInput = document.getElementById('folderInput');
    const fileTreeDiv = document.getElementById('fileTree');
    const processButton = document.getElementById('processButton');
    const outputArea = document.getElementById('outputArea');
    const statusDiv = document.getElementById('status');
    const fileTypeInput = document.getElementById('fileTypeInput');
    const selectByTypeBtn = document.getElementById('selectByTypeBtn');
    const deselectByTypeBtn = document.getElementById('deselectByTypeBtn');

    const step1Div = document.getElementById('step1-folder-select');
    const step2Div = document.getElementById('step2-file-tree-filter');
    const step3Div = document.getElementById('step3-output');

    const backToStep1Button = document.getElementById('backToStep1Button');
    const backToStep2Button = document.getElementById('backToStep2Button');
    const resetButton = document.getElementById('resetButton');


    let fileSystemTree = new Map();
    let allFileObjects = [];

    // --- æ­¥é©Ÿå°èˆª ---
    function showStep(stepIdToShow) {
        [step1Div, step2Div, step3Div].forEach(step => {
            step.style.display = (step.id === stepIdToShow) ? 'block' : 'none';
        });
        const activeStep = document.getElementById(stepIdToShow);
        if (activeStep) {
            // çµ¦ç€è¦½å™¨ä¸€é»æ™‚é–“æ¸²æŸ“ display:blockï¼Œå†æ»¾å‹•
            setTimeout(() => {
                 activeStep.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 50);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        showStep('step1-folder-select');
    });

    folderInput.addEventListener('change', handleFolderSelect);
    processButton.addEventListener('click', () => {
        generateOutput(); // ç”¢ç”Ÿè¼¸å‡ºå¾Œæœƒè‡ªå‹•è·³è½‰
    });
    selectByTypeBtn.addEventListener('click', () => filterByType(true));
    deselectByTypeBtn.addEventListener('click', () => filterByType(false));
    
    backToStep1Button.addEventListener('click', resetAndGoToStep1);
    backToStep2Button.addEventListener('click', () => showStep('step2-file-tree-filter'));
    resetButton.addEventListener('click', resetAndGoToStep1);


    fileTreeDiv.addEventListener('change', (event) => {
        if (event.target.type === 'checkbox') {
            const path = event.target.dataset.path;
            const isChecked = event.target.checked;
            const node = findNodeByPath(path, fileSystemTree);
            if (node) {
                updateSelectionState(node, isChecked, true); // true è¡¨ç¤ºç”±ç”¨æˆ¶ç›´æ¥æ“ä½œ
            }
        }
    });

    function resetAndGoToStep1() {
        folderInput.value = ""; // æ¸…ç©ºæª”æ¡ˆé¸æ“‡å™¨ (ç”¨ç©ºå­—ä¸²æ¯”nullæ›´å¯é )
        fileSystemTree.clear();
        allFileObjects = [];
        fileTreeDiv.innerHTML = 'è«‹å…ˆåœ¨æ­¥é©Ÿ 1 é¸æ“‡ä¸€å€‹è³‡æ–™å¤¾';
        outputArea.value = '';
        statusDiv.textContent = '';
        fileTypeInput.value = '';
        showStep('step1-folder-select');
    }

    function handleFolderSelect(event) {
        const files = event.target.files;
        if (!files.length) {
            // å¦‚æœä½¿ç”¨è€…å–æ¶ˆé¸æ“‡æˆ–é¸æ“‡ç©ºè³‡æ–™å¤¾ï¼Œä¸è¦åœç•™åœ¨æ­¥é©Ÿ2çš„ç©ºç‹€æ…‹
            // ä¿æŒåœ¨æ­¥é©Ÿ1ä¸¦æç¤º
            fileTreeDiv.innerHTML = 'æœªé¸æ“‡ä»»ä½•è³‡æ–™å¤¾æˆ–è³‡æ–™å¤¾ç‚ºç©ºã€‚';
            statusDiv.textContent = '';
            // folderInput.value = ""; // ç¢ºä¿ä¸‹æ¬¡ change äº‹ä»¶èƒ½è§¸ç™¼
            // showStep('step1-folder-select'); // ç•™åœ¨æ­¥é©Ÿ1
            // alert("æ‚¨æ²’æœ‰é¸æ“‡ä»»ä½•æª”æ¡ˆæˆ–è³‡æ–™å¤¾ï¼Œæˆ–è€…é¸æ“‡çš„è³‡æ–™å¤¾æ˜¯ç©ºçš„ã€‚è«‹é‡è©¦ã€‚");
            // ^ ä¸Šè¿°è¡Œç‚ºå¦‚æœä½¿ç”¨è€…åªæ˜¯é—œé–‰å°è©±æ¡†è€Œæœªé¸ä»»ä½•æ±è¥¿ï¼Œæœƒæœ‰é»ç…©äººã€‚
            // ç°¡å–®åœ°è¿”å›ï¼Œè®“UIåœåœ¨æ­¥é©Ÿ1å³å¯ã€‚
            // å¦‚æœæ˜¯å¾æ­¥é©Ÿ2è¿”å›é‡æ–°é¸æ“‡ï¼ŒfolderInput.valueå·²ç¶“è¢«æ¸…ç©ºäº†ã€‚
            // å¦‚æœæ˜¯é¦–æ¬¡é¸æ“‡å°±æ²’é¸ï¼Œé‚£éº¼files.lengthç‚º0ï¼Œä¹Ÿä¸æœƒé€²å…¥ä¸‹ä¸€æ­¥ã€‚
            return;
        }

        statusDiv.textContent = 'æ­£åœ¨å»ºç«‹æª”æ¡ˆæ¨¹...';
        fileSystemTree.clear();
        allFileObjects = Array.from(files);

        for (const file of allFileObjects) {
            const pathParts = file.webkitRelativePath.split('/');
            let currentLevel = fileSystemTree;
            let currentPath = [];

            for (let i = 0; i < pathParts.length; i++) {
                const part = pathParts[i];
                currentPath.push(part);
                const nodePath = currentPath.join('/');

                if (i === pathParts.length - 1) { // File
                    if (!currentLevel.has(part)) {
                         currentLevel.set(part, {
                            name: part, type: 'file', path: nodePath,
                            fileObject: file, selected: false, children: null
                        });
                    }
                } else { // Folder
                    if (!currentLevel.has(part)) {
                        currentLevel.set(part, {
                            name: part, type: 'folder', path: nodePath,
                            selected: false, children: new Map()
                        });
                    }
                    if (currentLevel.get(part).type === 'file') { // Correct if mistakenly identified as file
                        currentLevel.get(part).type = 'folder';
                        currentLevel.get(part).children = currentLevel.get(part).children || new Map();
                        currentLevel.get(part).selected = true;
                    }
                    currentLevel = currentLevel.get(part).children;
                }
            }
        }
        renderFileTree();
        statusDiv.textContent = `å·²è¼‰å…¥ ${allFileObjects.length} å€‹é …ç›®ã€‚é è¨­å…¨é¸ã€‚`;
        showStep('step2-file-tree-filter');
    }

    function renderFileTree() {
        fileTreeDiv.innerHTML = '';
        const rootUl = document.createElement('ul');
        appendTreeNodes(fileSystemTree, rootUl);
        fileTreeDiv.appendChild(rootUl);
    }

    function appendTreeNodes(nodeMap, parentElement) {
        const sortedEntries = [...nodeMap.entries()].sort(([keyA, valA], [keyB, valB]) => {
            if (valA.type === 'folder' && valB.type === 'file') return -1;
            if (valA.type === 'file' && valB.type === 'folder') return 1;
            return keyA.localeCompare(keyB);
        });

        for (const [name, node] of sortedEntries) {
            const li = document.createElement('li');
            
            const randomSuffix = Math.random().toString(36).substring(2, 7);
            const checkboxId = `cb-${node.path.replace(/[^a-zA-Z0-9_-]/g, '_')}-${randomSuffix}`;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = checkboxId;
            checkbox.checked = node.selected;
            checkbox.dataset.path = node.path;

            const label = document.createElement('label');
            label.htmlFor = checkboxId;

            const labelTextSpan = document.createElement('span');
            labelTextSpan.classList.add('label-text');
            let icon = node.type === 'folder' ? 'ğŸ“ ' : 'ğŸ“„ ';
            labelTextSpan.textContent = icon + node.name;
            
            label.appendChild(labelTextSpan);

            li.appendChild(checkbox);
            li.appendChild(label);

            node.checkboxElement = checkbox; 

            if (node.type === 'folder' && node.children && node.children.size > 0) {
                const childrenUl = document.createElement('ul');
                appendTreeNodes(node.children, childrenUl);
                li.appendChild(childrenUl);
            }
            parentElement.appendChild(li);
        }
    }
    
    function findNodeByPath(path, currentMapLevel) {
        const parts = path.split('/');
        let node = null;
        let currentLevel = currentMapLevel;
        for (const part of parts) {
            if (!currentLevel || !currentLevel.has(part)) return null;
            node = currentLevel.get(part);
            if (node.type === 'folder' && node.children) {
                currentLevel = node.children;
            } else if (parts.indexOf(part) < parts.length -1 ) { 
                return null;
            }
        }
        return node;
    }
    
    function updateSelectionState(node, isSelected, isUserInteraction) {
        node.selected = isSelected;
        if (node.checkboxElement) node.checkboxElement.checked = isSelected;

        if (node.type === 'folder' && node.children) {
            for (const childNode of node.children.values()) {
                updateSelectionState(childNode, isSelected, false); 
            }
        }
    }


    function filterByType(select) {
        const typesString = fileTypeInput.value.trim();
        if (!typesString) {
            alert('è«‹è¼¸å…¥è¦ç¯©é¸çš„æª”æ¡ˆé¡å‹ï¼Œä¾‹å¦‚ .txt, .js');
            return;
        }
        const types = typesString.split(',').map(t => t.trim().toLowerCase()).filter(t => t.startsWith('.'));
        if (!types.length) {
            alert('ç„¡æ•ˆçš„æª”æ¡ˆé¡å‹æ ¼å¼ã€‚è«‹ç¢ºä¿ä»¥ . é–‹é ­ï¼Œä¾‹å¦‚ .py');
            return;
        }

        let changedCount = 0;
        function traverseAndFilter(nodeMap) {
            for (const node of nodeMap.values()) {
                if (node.type === 'file') {
                    const fileExt = node.name.substring(node.name.lastIndexOf('.')).toLowerCase();
                    if (types.includes(fileExt)) {
                        if (node.selected !== select) {
                            node.selected = select;
                            if (node.checkboxElement) node.checkboxElement.checked = select;
                            changedCount++;
                        }
                    }
                } else if (node.type === 'folder' && node.children) {
                    traverseAndFilter(node.children);
                }
            }
        }
        traverseAndFilter(fileSystemTree);
        if (changedCount > 0) {
            statusDiv.textContent = `å·²æŒ‰é¡å‹ ${types.join(', ')} ${select ? 'é¸å–' : 'å–æ¶ˆé¸å–'} äº† ${changedCount} å€‹æª”æ¡ˆã€‚`;
        } else {
            statusDiv.textContent = `æŒ‰é¡å‹ ${types.join(', ')} ç¯©é¸ï¼šæ²’æœ‰æª”æ¡ˆçš„é¸å–ç‹€æ…‹è¢«æ”¹è®Šã€‚`;
        }
    }

    async function generateOutput() {
        outputArea.value = '';
        statusDiv.textContent = 'æ­£åœ¨è®€å–æª”æ¡ˆå…§å®¹...';
        showStep('step3-output'); 

        let outputContent = '';
        let filesProcessed = 0;
        let filesToRead = [];

        function collectSelectedFiles(nodeMap) {
            const sortedEntries = [...nodeMap.entries()].sort(([keyA, valA], [keyB, valB]) => {
                return valA.path.localeCompare(valB.path);
            });
            for (const [name, node] of sortedEntries) {
                if (node.type === 'file' && node.selected && node.fileObject) {
                    filesToRead.push(node);
                } else if (node.type === 'folder' && node.children) {
                    collectSelectedFiles(node.children);
                }
            }
        }

        collectSelectedFiles(fileSystemTree);
        
        if (filesToRead.length === 0) {
            outputArea.value = "æ²’æœ‰é¸å–ä»»ä½•æª”æ¡ˆã€‚";
            statusDiv.textContent = "å®Œæˆã€‚æ²’æœ‰æª”æ¡ˆå¯è™•ç†ã€‚"; 
            document.getElementById('step3-output').querySelector('#outputArea').placeholder = "æ²’æœ‰é¸å–ä»»ä½•æª”æ¡ˆã€‚";
            return;
        }

        let updateCount = 0;
        for (const node of filesToRead) {
            try {
                const fileContent = await node.fileObject.text();
                outputContent += `è·¯å¾‘/${node.path}å…§å®¹å¦‚ä¸‹ï¼š\n`;
                outputContent += `${fileContent}\n\n`;
                filesProcessed++;
                updateCount++;
                if (updateCount % 10 === 0 || filesProcessed === filesToRead.length) { 
                    outputArea.placeholder = `æ­£åœ¨è™•ç†... å·²è®€å– ${filesProcessed} / ${filesToRead.length} å€‹æª”æ¡ˆã€‚`;
                }
            } catch (error) {
                outputContent += `è·¯å¾‘/${node.path}å…§å®¹å¦‚ä¸‹ï¼š\n`;
                outputContent += `[éŒ¯èª¤ï¼šç„¡æ³•è®€å–æª”æ¡ˆå…§å®¹ - ${error.message}]\n\n`;
                console.error(`è®€å–æª”æ¡ˆ ${node.path} å¤±æ•—:`, error);
            }
        }

        outputArea.value = outputContent;
        outputArea.placeholder = "é¸å–çš„æª”æ¡ˆå…§å®¹å°‡æœƒé¡¯ç¤ºåœ¨é€™è£¡..."; 
        statusDiv.textContent = `å®Œæˆã€‚å…±è™•ç† ${filesProcessed} å€‹æª”æ¡ˆã€‚çµæœé¡¯ç¤ºåœ¨æ­¥é©Ÿ 3ã€‚`;
    }

</script>

</body>
</html>